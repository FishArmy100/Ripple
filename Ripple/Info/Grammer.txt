// Using the Maple Syntax


grammer Ripple
{
	// Utilites:
	Parameters = "(" (TypeName Identifier ("," TypeName Identifier))* ")";
	ExpressionList = Expression ("," Expression)*;
	TypeList = TypeName ("," TypeName)*;
	GenericParams = "<" (TypeName | IDENTIFIER | Lifetime)* ">";
	GenericArgs = "<" (TypeName | Expression | Lifetime)* ">";

	IntLiteral = DIGIT+;
	FloatLiteral = DIGIT+ "." DIGIT+;
	CharLiteral = "\'" CHARACTOR "\'";
	StringLiteral = C_STRING_LITERAL;

	// Types:
	GroupedType = "(" TypeName ")";
	PointerType = TypeName "mut"? "*";
	ReferenceType = TypeName "mut"? "&" Lifetime?;
	ArrayType = TypeName "mut"? "[" IntLiteral "]";
	FuncPtr = "mut"? "(" TypeList ")" "->" TypeName;
	GenericType = IDENTIFIER GenericArgs

	TypeName = GroupedType			|
			   PointerType			|
			   ReferenceType		|
			   FuncPtr				|
			   GenericType			|
			   ("mut"? IDENTIFIER);

	Lifetime = "'" IDENTIFIER;

	ClassVisibility = "public" | "private";

	// Expressions:
	InitalizerList = "{" ExpressionList "}";

	Grouping = "(" Expression ")";
	MemberSelection = Expression ("." IDENTIFIER)*;
	Construction = TypeName "(" ExpressionList? ")";

	Primary = IntLiteral		|
	          FloatLiteral		|
			  Grouping			|
			  "true"			|
			  "false"			|
			  StringLiteral		|
			  CharLiteral		|
			  IDENTIFIER		|
			  InitalizerList	|
			  MemberSelection	|
			  Construction;
			  

	Call = MemberSelection GenericArgs? "(" ExpressionList? ")";
	Index = Expression "[" Expression "]";

	Unary = ("!" | "-" | "&" | "*") Unary | (Call | Index);

	Factor = Unary (("*" | "/" | "%") Unary)*
	Term = Factor (("+" | "-") Factor)*
	Comparison = Factor ((">=" | ">" | "<" | "<=") Factor)*
	Equality = Comparison (("!=" | "==") Comparison)*;

	LogicalAnd = Equality ("&&" Equality)*;
	LogicalOr = LogicalAnd ("||" LogicalOr)*;

	Casting = LogicalOr ("as" TypeName)*

	Assignment = Casting "=" Assignment | Casting;

	Expression = Assignment;

	// Statements:
	ExprStmt = Expression ";";
	Block = "{" Statement* "}";
	IfStmt = "if" "(" Expression ")" Statement;
	ForStmt = "for" "(" VarDecl? ";" Expression? ";" Expression? ";" ")" Statement;
	WhileStmt = "while" "(" Expression ")" Statement;
	ReturnStmt = "return" Expression? ";";
	BreakStmt = "break" ";";
	ContinueStmt = "continue" ";";

	// Declarations:
	VarDecl = TypeName IDENTIFIER ("," IDENTIFIER)* ("=" Expression)? ";";
	FuncDecl = "func" IDENTIFIER GenericParams? Parameters "->" TypeName Block;
	ExternFuncDecl = "extern" StringLiteral "func" IDENTIFIER Parameters "->"  TypeName ";";

	MemberDecl = ClassVisibility ("mut"? FuncDecl | VarDecl);
	ClassDecl = "class" IDENTIFIER GenericParams? "{" MemberDecl* "}"

	ExternMemberDecl = TypeName IDENTIFIER ("," IDENTIFIER)* | 
					   "func" IDENTIFIER Parameters "->"  TypeName ";";

	ExternClassDecl = "extern" StringLiteral "class" IDENTIFIER "{" "}";

	Statement = ExprStmt		| 
				Block			| 
				IfStmt			| 
				ForStmt			| 
				WhileStmt		| 
				VarDecl			| 
				ReturnStmt		| 
				ContinueStmt	| 
				BreakStmt;
	
	Declaration = VarDecl			|
				  FuncDecl			|
				  ExternFuncDecl	|
				  ClassDecl			|
				  ExternClassDecl;

	File = Declaration* EOF;

	main Program = File*;
}