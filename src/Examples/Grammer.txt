
Grammer Key: Based on https://craftinginterpreters.com/representing-code.html
	Rule: Terminal -> "Non Terminal" "In Series";
	Series of Productions seperated by: |
	Can be grouped using: ()
	Thing reapeted 0 or more times prefix: *
	Thing reapeated 1 or more times prefix: +
	Thing reapeated 0 or 1 times prefix: ?
	Between <> = complex rule
	Comments: // example comments




Basic Rules: created in lexer
	DIGIT -> "0" ... "9";
	charactor -> <any charactor exept ' and ">
	CHAR -> "'" charactor "'";
	STRING -> """ charactor* """;
	INT -> DIGIT+;
	FLOAT -> DIGIT+ "." DIGIT+;
	ALPHA -> "a" ... "z" | "A" ... "Z" | "_";
	IDENTIFIER -> ALPHA (ALPHA | DIGIT)*;


Utility Rules:
	parameters		-> typeName IDENTIFIER ("," typeName IDENTIFIER)*;
	arguments		-> expression ("," expression)*;

Expression Rules:
	call			-> IDENTIFIER "(" arguments? ")";
	primary			-> INT | FLOAT | CHAR | STRING | call | IDENTIFIER | "(" expression ")";
	unary			-> ("-" | "!" | "~") unary | primary;

	factor			-> unary (("*" | "/" | "%") unary)*; // Example: 5 * -3 / 2;
	term			-> factor (("+" | "-") factor)* // Example: 5 + (3 * 2);
	bitshift		-> term (("<<" | ">>") term)*
	bit_and			-> bitshift ("&" bitshift)*;
	bit_xor			-> bit_and ("^" bit_and)*;
	bit_or			-> bit_xor ("|" bit_xor)*;
	comparison		-> bit_or ((">" | ">=" | "<" | "<=") bit_or)*;
	equality		-> comparison (("==" | "!=") comparison)*;
	logic_and		-> equality ("&&" equality)*;
	logic_or		-> logic_and ("||" logic_and)*;
	assignment		-> IDENTIFIER "=" logic_or;

	expression		-> assignment;

Statement Rules:
	typeName		-> "int" | "float" | "string" | "char" | "object" | "uint" | IDENTIFIER;

	varDecl			-> typeName IDENTIFIER ( "=" expression)? ";";

	
	funcDecl		-> typeName IDENTIFIER "(" parameters? ")" block;
	returnStmt		-> "return" expression? ";";

	declaration		-> varDecl | funcDecl

	exprStmt		-> expression ";";
	ifStmt			-> "if" "(" expression ")" statement
					( "else" statement )?;
	whileStmt		-> "while (" expression ")" 
							statement;
	forStmt			-> "for (" (varDecl | exprStmt | ";") expression? ";" expression? ")"
							statment;

	continueStmt	-> "continue;";
	breakStmt		-> "break;";

	statement		-> declaration 
					 | exprStmt 
					 | ifStmt 
					 | block 
					 | continueStmt 
					 | breakStmt;
					 | returnStmt;

	block			->  "{" statement* "}";

	program			-> declaration*  EOF; // final ast for a file

