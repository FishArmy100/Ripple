
Grammer Key: Based on https://craftinginterpreters.com/representing-code.html
	Rule: Terminal -> "Non Terminal" "In Series";
	Series of Productions seperated by: |
	Can be grouped using: ()
	Thing reapeted 0 or more times prefix: *
	Thing reapeated 1 or more times prefix: +
	Thing reapeated 0 or 1 times prefix: ?
	Between <> = complex rule
	Comments: // example comments




Basic Rules: created in lexer
	DIGIT -> "0" ... "9";
	charactor -> <any charactor exept ' and ">
	CHAR -> "'" charactor "'";
	STRING -> """ charactor* """;
	INT -> DIGIT+
	FLOAT -> DIGIT+ "." DIGIT+
	ALPHA -> "a" ... "z" | "A" ... "Z" | "_"
	IDENTIFIER -> ALPHA (ALPHA | DIGIT)*



Expression Rules:
	primary			-> INT | FLOAT | "(" expression ")";
	unary			-> "-" unary | primary;

	factor			-> unary (("*" | "/" | "%") unary)*; // Example: 5 * -3 / 2;
	term			-> factor (("+" | "-") factor)* // Example: 5 + (3 * 2);
	comparison		-> term ((">" | ">=" | "<" | "<=") term)*;
	equality		-> comparison (("==" | "!=") comparison)*;
	logic_and		-> equality ("&&" equality)*;
	logic_or		-> logic_and ("||" logic_and)*;
	assignment		-> IDENTIFIER "=" logic_or;
	
	expression		-> assignment;

	varDecl			-> IDENTIFIER IDENTIFIER ( "=" expression)? ";";
	declaration		-> varDecl

	exprStmt		-> expression ";";
	ifStmt			-> "if" "(" expression ")" statement
					( "else" statement )?;
	whileStmt		-> "while (" expression ")" 
							statement;
	forStmt			-> "for (" (varDecl | exprStmt | ";") expression? ";" expression? ")"
							statment;

	continueStmt	-> "continue;";
	breakStmt		-> "break;";

	statement		-> declaration 
					 | exprStmt 
					 | ifStmt 
					 | block 
					 | continueStmt 
					 | breakStmt;

	block			->  "{" statement* "}";

	program			-> declaration*  EOF; // final ast for a file

